---
layout: post
title: Leetcode刷题随笔
date: 2018-06-04 9:36
catagories: algorithm
---

# 分题目复习
## 对于动态规划的优化  
动态规划，如果不加任何优化的话，从本质上来讲就是枚举算法，对于动态规划的优化主要是利用memory table来将已经计算过的结果存储起来，避免后面的重复计算

## 对于不同进制之间的转化
* Leetcode 168 *
对于10进制，如果需要将其转化为k进制，则按照如下步骤进行操作  
* 取该数在十进制乘法下对k的模m，即为转换后最低位的数字  
* 将该数除以k，取整数部分，递归调用转换函数

## C++STL中的unique()函数  
这个函数的作用是去除vector中（或者其它容器中）**相邻** 位置的重复元素，而且其只是将重复的元素移到了队尾并没有删除，因此想要使用这个函数来删除重复元素需要按照如下使用方式  
{% highlight c++ %}
#include <vector>
#include <algorithm>

using std::vector;

int main() {
	vector<int> vec = {1, 2, 3, 1};
	std::sort(vec.begin(), vec.end());
	vec.erase(std::unique(vec.begin(), vec.end()), vec.end());
	return 0;
}
{% endhighlight %}  
上述代码中，由于vec中的重复元素“1”没有处在相邻的位置，如果直接使用unique的话没有任何改变发生，因此需要先排序，将重复的元素集中在一起。unique函数返回的是第一个重复元素的位置，因此可以直接利用erase函数将重复元素删除。

## 74. Search a 2D Matrix
该题目为的是快速地在二维矩阵中搜索目标值，为了达到高速搜索的目的，容易想到的便是使用binary search，但是需要注意，如果将二维矩阵的所有元素拉通进行查找不利于充分使用cache，因此考虑一行一行进行搜索，同时需要注意的是，每行在进行搜索时，可以通过判断第一个以及最后一个元素与目标值的大小来减少搜索次数

## 75. Sort Colors
该题目表明，如果要求是排序，也不一定是要真正地去执行排序的动作（例如交换），可以采用计数+直接赋值的方法实现

## 77. Combination
在计算Combination时，可以考虑利用已经计算的结果生成新的结果，而不是每次都重新计算。例如，结果[2,3,4]，稍微进行修改便可以得到新的结果[1,3,4]，这样可以有效地提高程序的效率

## 78. Subsets
所有这种类似的题目，例如寻找所有可能的Combination、Permutation等等，都可以利用一个通用的模版，即backtracking的思路。具体为：使用一个循环，通过每次新加入一个元素，然后递归调用，每次递归时率先判断是否满足条件，若满足则将其加入最后结果中，递归调用的函数返回后删除刚刚加入的元素，并进入下轮循环，具体做法可以参考[Leetcode中的这篇文章](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))

## 79. Word Search
该题目是一个寻常的，利用回溯法解决的搜索类型的题目，但有一点值得注意以下，即对于这种每一步有多种可能的题目时，我们可以选择先判断，然后只去递归那些符合条件的，也可以选择先递归，然后在每个递归函数的一开始判断是否符合要求。显然，采用第二种方法会简化代码，值得尝试

## 80. Remove Duplicates from Sorted Array II
该题目与Remove Duplicates from Sorted Array一样，具体思想其实就是要明白删除元素不一定需要真正意义上的删除，可以通过使用一个指针的方式，指向待删除的元素，然后将后面不需要删除的元素移到该位置上，以此达到删除的目的

## 81. Search in Rotated Sorted Array II
该题目与81. Search in Rotated Sorted Array I一样，我们需要找到中间的旋转轴（pivot point），不过在寻找旋转轴的过程中，我们可以综合进行binary search，以此加快速度。具体方法为：使用binary search的框架，每次率先判断是否已经找到，如果是则直接返回，否则的话看mid位置的元素与start位置的元素关系如何，因此如果mid处的元素小于start处的元素，我们则可以确定前半部分是乱序的，而后半部分是有序的，然后再判断目标是否位于后半部分元素间（常用这种方法进行排除，即比较目标与第一个和最后一个元素的大小），如果在的话直接在后半部分进行二分查找，另外情况同理。如果不在后半部分，那么递归调用搜前半部分即可。本题麻烦的地方在于，如果我们发现start与mid元素相同，那么前半部分可能无序也可能有序，如果此时end位置的元素也相同，那么则可肯定前半部分无序，否则前半部分全部相同

## 82. Remove Duplicates from Sorted List II
在消除链表/数组中的重复元素时，根据题目的要求，如果是要求删除掉所有删除的元素（即只要出现过重复，就全部删除）那么就比较该元素与其前一个元素的值关系，如果相同就跳过，但要记住最后一个元素也得跳过；如果要求的只是删除重复的，那么就比较元素与其前一个元素，然后如果相同就跳过即可。同时需要注意，在原链表上进行魔改时，需要关注最后尾指针有没有置空！！

## 86. Partition List
本题没有想象中的复杂，对于链表类型的问题，从原链表中挑出一部分组成新的链表，并不会使用多余的内存，这是因为其本身只是指针的移动赋值改变而已。在本题中，我们可以创建两个头指针，遍历原链表时，将小于x的节点接在第一个链表后，大于等于x的接在第二个链表后即可，最后再将其拼接即可  
同时，有个技巧需要注意，我们一般在做到链表有关的题目时，在往一个空的链表中添加节点时，往往异常麻烦，这是因为我们需要判断头指针是否为空，而且往往需要两个指针来控制着一头一尾。为了改进这样的麻烦，我们可以为每个链表创建一个空白的，头节点，这样的一个头节点的好处有二：  
1. 插入操作时无需判断
2. 天然存在一个头节点在那里，我们可以在任何时候直接通过它来获取到我们链表的头指针

## 89. Gray Code
对于Gray Code，其存在着天然的对称及递归性。即，对于Gray Code来说，n=k的Gray Code等于n=k-1的Gray Code，再加上一个对称操作，并把得到的下半部分的编码的最高位置1即可  
当然，在讨论区也发现了一个非常聪明的做法——同样利用递归并使用一种为bitset的数据结构，这种数据结构类似数组，但是其每个元素只能取0或1，其可以实现某一位元素的翻转操作，以及将整个数组转化为一个长整型这一操作。算法的base的情况为：当n=0时，将当前的bitset转为整型并加入结果中；递归情况为：首先递归调用n-1时的情况，这一调用可以得到n-1时的Gray Code，接下来翻转bitset中第n-1位的值，再递归调用n-1，此时可以得到对称翻转后的Gray Code，合起来就是最终结果  
可以看到，上述操作中，在参数为k的调用中，我们只会翻转第k-1位的值，因此当我们翻转后再进行调用时，对于参数为k-1的递归函数来说，第k-1位的值对其是不可见的，其还是相当于在生成k-1位的Gray Code，只是其不知道第k-1位此刻已经是1，这样就完美地达到了翻转的目的

## 1008. Construct Binary Search Tree from Preorder Traversal
使用前序遍历的结果来重建二叉搜索树，过程其实非常简单。对于前序遍历来说，其先遍历树的根，然后是左子树，最后是右子树，因此在我们得到的前序遍历序列中，其可以被分为三部分，即根+左子树+右子树，我们只需要分辨出这三个部分，然后分别递归调用构建即可。分辨也很简单，只需要找出序列中取值小于根节点的，即为左子树的，大于根节点的，即为右子树的。对于后序遍历的序列，也可以采用类似的方法，因为在后序遍历的序列中，根节点一定是最后一个。但是中序遍历，则不一定了  
还有一种题型，是通过前序遍历+中序遍历来恢复二叉树，需要注意的是，由于不是二叉搜索树，因此节点之间的大小关系不复存在，因此只能先通过在前序遍历中确定根节点（即第一个），然后去中序遍历中找到对应节点左边（左子树）和右边（右子树）的所有节点，然后递归调用，递归中也是通过类似的方式来进行寻找

## 594. Longest Harmonious Subsequence
做题时需要注意首先观察题目细节。在该题中，我们可以发现，虽然题目说符合要求的数组是数组的最大值和最小值相差1，但是其实说的就是由两个值相差1的元素构成的数组。因此我们可以考虑两种解决方案：
1. 首先对数组排序，这样元素按照其大小排序，我们只需要看周围的两个元素即可
2. 使用map这一数据结构，首先遍历一遍数组，统计里面每个元素的出现次数，接下来遍历map中有的元素，同时查看比其大1的元素是否存在，如果存在则将其两者的计数相加即可

## 593. Valid Square
本题有两点需要注意
1. 对于四个点在空间中组成的正方形，其不一定是平行x轴的那种，也可以是斜着的。因此正确的，用于判断是否能够构成正方形的方法为：计算各个顶点之间的距离，同时其必需满足有四个相同（对应四条边），另外两个相同（对应对角线）
2. 对于比较考虑值是否相同的问题，可以考虑使用set这一数据结构。具体为：如果题目中只是需要知道给定的元素中是否有相同的元素，而不关心是哪几个，那么可以将其全部加入set中，然后看最后结果的数量。对于本题即为，因为我们只需要看六组数据能否被分为两组，因此将其插入set中然后看set的size是否为2即可  

## 229. Majority Element II
本题的实现采用的是名为摩尔投票法的算法（Boyer-Moore Majority Vote Algorithm），该算法可以用于获得一组数字中，出现次数最多的n个元素。具体的实现方法为：如果要找出最多的n个元素，那么需要维护n个元素（Majority）及其计数器（Counter），接下来，遍历整个数组，如果遇到了这两个元素中的一个，将对应的那个加1，然后如果遇到的是一个新的元素，首先看目前的counter中有无等于0的，如果有的话，将其中一个计数器为0的元素进行替换，变为现在的这个元素，如果没有等于0的，则将所有的计数器都减1  
摩尔投票法的本质即为选出目前认为是最多的几个元素，同时在遇到不属于这几个元素的新元素时做删除操作，如果将某个元素删完了但是又遇到了新的元素，说明我们目前的假设错误，因此应该将新的这个元素作为多数元素  
需要注意的一点是，在本题中，选出了最多的两个元素，但是不一定这两个元素都出现了多于n/3次，因此应该再遍历一遍数组进行检查

## 456. 132 Pattern
本题有两种思路：
1. 题目要求寻找的是三个元素构成的子串，同时需要满足中间元素是三者之中的最大值。一个很自然的想法就是，我们可以先确定两边的元素，然后在中间寻找比两边都大的元素。同时，易见的一点是，两边的元素相距越远，我们能够找到符合要求的第三个元素的机会就越高。因此，我们只需要从最右边开始，接下来从最左边开始寻找第一个比其小的元素，然后再在其中间寻找一个最大的元素即可，如果没找到，则将最右端的元素往左移一个（没找到说明我们找的元素太大了，因此需要往内移动将其变小）
2. 一种非常tricky的思路是：使用一个栈，同时从右往左扫描数组，每当我们遇到一个新的元素时，弹出栈内比其小的所有元素，然后将其入栈，同时将最后一个被弹出来的元素作为可能的中间元素的候选，如果某次扫描得到的元素小于中间元素的候选，那么则代表我们找到了132序列。上述算法能够成功的原因在于，首先栈中的元素一定是按照从小到大的顺序由栈顶到栈底的，同时，任何一个被弹出的元素，是因为小于当前入栈的元素，而被我们作为候选的元素，是这些元素中最大的，因此这一过程其实相当于当我们找到一个新元素，且其不能被作为S1时，我们将其作为S2，然后看能否找到更大的S3（即其实每次遍历到新元素，且该元素无法组成132序列时，都考虑，目前这个元素能否让我们使用一个更大的S3值）

## 345. Reverse Vowels of a String
本题需要注意一点，即元音不止是小写字母，大写字母也有可能  
这种类似的翻转XXX题目的标准做法很简单：利用两个指针，一个从开头开始，一个从尾部开始，然后当两者都遇到符合条件的字符时，交换即可，这样即可达到reverse的目的

## 725. Split Linked List in Parts
本题目是对于链表的操作题目，具体的思路也很平常，首先用一个循环统计出链表中元素的总数，然后再通过一个循环每次截取一定数量的节点出来作为新的链表，但是有一点需要注意：ceil函数以及floor函数的参数和返回值都是double型的变量，如果我们对两个int型变量的商用ceil函数时，一定要注意需要先把他们转化为double型，否则的话，int型本身的出发是向下取整的，这样使用ceil函数便完全没有意义

## 116. Populating Next Right Pointers in Each Node
本题只允许使用O(1)的空间，若使用递归的话（虽然递归也会使用栈空间）解题思路主要为：在根节点处将自己的左子树的根节点连到右子树的根节点，同时，根据自己的next指针是否为空，可以判断右方有无其他节点，如果有的话，则将自己右子树的根节点的next指针赋为自己右边兄弟节点的左子树根节点，然后递归调用处理左子树和右子树即可  
如果不想使用递归，可以将其转化为迭代，注意到其实我们可以通过一层层的进行处理来达到目标，因此迭代解法的思路为：首先基本思路与上方递归的相同，但是在处理完本节点的左子树和右子树的根节点后，还要继续去处理兄弟节点，直到为空

## 638. Shopping Offers
vector作为key可以直接在map中进行使用，但是无法在unordered\_map中使用，若要使用可以选择重载hash函数或者可以转而使用一个类型为<int, int>的unorder\_map，其中的key通过将vector中的每个元素乘以10^i再求和来完成（其中i为下标）

## 713. Subarray Product Less than K
对于出现了乘积的问题，如果担心乘积结果可能会产生溢出，可以考虑将其转化为log对数的形式，但是需要注意的是，由于log的结果为浮点数，因此在比较时需要采用a-b<1\*10^{-9}的方式进行

## 823. Binary Trees With Factors
* 对于答案需要mod后返回的题目，可能有坑，但很多时候利用long等即可轻松解决  
* 此题也是利用DP进行解决，问题的划分思路与我之前所做的题目都不太相同，其不是根据解题的步骤来划分，而是根据答案的不同情况来分类。在本题中需要观察到最终答案中的所有二叉树，其根节点一定是数组A中的元素，因此我们就可以按照其根节点的值来进行DP  
* 巧妙利用搜索，而不是暴力尝试，可以显著加快速度。例如此题中，对于每一个根节点的值，我们既可以选择穷举找到所有可能的子节点的值，也可以只穷举其中一个，另外一个采用搜索的方式获得

## 1072. Flip Columns For Maximum Number of Equal Rows
这一题主要是需要能够观察出解的特点，对于通过flip某些列得到的新矩阵A，对于其中元素全部相等的几个行，由于flip的时候是以列为单位的，因此对于flip前的这几个行，其一定满足
1. 两行完全相同
2. 两件刚好互补（0对1、1对0）

因此要求最大行数，我们只需要搜索原矩阵当中满足上述条件的所有行的集合中，元素最多的那个即可

## 5076. Greatest Common Divisor of Strings
通过这一题主要可以学习一下C++中string类有关substr和find函数的使用，这样遇到寻找子串的问题时，使用这两个函数比自己进行比较快速且准确得多

## 240. Search a 2D Matrix II
此题每次都搜索最左下角的元素，根据其与target的不同大小关系变换搜索条件，在二维平面同时开花，与平常一维数组的搜索不同，故称2D Matrix的搜索

## Rotate Array
对于此题，有多种解法：
* 使用类似冒泡的方法，将低n-k个元素冒泡到前面去（会超时，复杂度较高）
* 将元素拷贝到其对应下一位置处，同时使用一个临时变量存储下来刚刚替换掉的元素，一直到将所有元素都处理一遍
* 分析可得，我们的目的是将后k个元素挪到前k个位置，前n-k个元素挪到后n-k个位置。如果直接交换的话，虽然后k个元素都到达了指定位置，然而其内部顺序刚好相反，因此可以先考虑将前n-k个和后k个元素交换一下顺序，然后再将整体全部交换一个顺序

## 两个数组的交集 II
此题可以使用map来求解，有时我们有两个数组，且需要知道数组A中哪些元素在数组B中也出现时，将B中的元素全部插入map中，再利用map来比较，比两次循环快速很多

## 字符串中的第一个唯一字符
有时在已知元素可能取值的情况下我们可以用数组代替map，同时我们也经常使用这种方法来计数，以此方便地统计每个元素出现的次数

## 删除链表中的节点
注意一般删除链表都需要拿到前一节点，如果只给你待删除节点的话就得按照这道题的思路删除，即先将后一节点的内容拷贝，然后假装当前这一节点是前一节点，删除后一节点，但是这个方法只能删除非尾部节点

## 反转链表
反转链表有两种思路，一种可以递归的进行，另外一种是把节点一个个提取出来，然后从前面插入

## 二叉树的层次遍历
层次遍历首先想到的思路是BFS，但是如果对于一颗不完整的二叉树，需要把遍历到的元素区分到不同层，简单的BFS就不够用了。为了完成区分，可以有两种思路。  
1. 使用递归的思路，同时传参时明确是第几层
2. 使用BFS的思路，但是压入队列中的是一个二元组，另外多余的元素用来指示当前节点的层数

## 洗牌算法
洗牌算法的数学原理来自于N个人中抽一个人获奖，大家按照次序依次抽，不管谁先谁后，只要不揭晓答案，每个人被抽中的概率就是一样的。对于洗牌算法来说，对于长度为n的数组，第一次生成一个0到n-1的随机数r，然后交换第n-1和第r个元素，这样就完成了一个元素位置的确定。接下来，再生成一个0到n-2的随机数，重复处理。上述步骤中，每个元素出现在最后结果上的每个位置的概率都是1/n（证明利用的就是抽奖的证明），因此是一个合理的洗牌。还有许多其它洗牌算法，可以针对例如数组长度不知道的情况，具体可参照[这里](https://blog.csdn.net/qq_26399665/article/details/79831490)

## 计数质数
这道题有很多种方法  
1. 首先一种最常规的就是遍历2到n的所有数字，然后依次判断每个数字是否为质数。这种方法的问题在于效率较低，如果使用的是依次比较到根号n的这种朴素算法会很花费时间。判断一个数字是否为指数也可以使用一种改进的算法，这一改进算法利用了质数的一个性质，也即除了2和3之外，其余任何一个质数只会出现在6i-1和6i+1这两个位置（i大于等于1），但是需要注意的是，出现在这两个位置的元素也不一定是质数，还需要再次判断，但是在判断时，我们可以发现其实只有6k-1和6k+1处的元素需要判断（k小于i），这是因为对于6i、6i+2、我6i+4，其都是偶数，而6i-1和6i+1都是偶数，不可能被其整除。对于6i+3，同样需要为3的倍数才能被整除，也不满足。（**在实现时，一定要注意在判断处在6k-1和6k+1处的元素是否为质数时，i是从5开始遍历到根号n，这是因为如果从6开始，那么有时候可能会漏判断一次，然而判断总是宁多勿少的**）
2. 第二种算法利用了题目的优势，因为本题不是单纯的判断素数，而是找所有n以内的素数。因此在每判断完成一个数之后，这个数的倍数肯定都不是素数，因此可以维护一个数组记录每个数是否可能为素数，然后在每次判断完后都去把不可能的元素对应的位置改为false，这样可以极大地节约时间
3. 第三种算法是被称为埃拉托斯特尼筛法的方法。对于上面的第二种方法，观察易见，如果某个元素在遍历到它时没有被标为false，则代表小于它的所有元素都不是它的因数，那么它肯定是质数。同时，我们也只需要遍历到根号n，因为对于大于根号n的所有元素，如果此时其仍未被标记，代表其不存在小于根号n的因数，而这些数都小于n，因此绝对不可能存在两个大于根号n的因数，因此其肯定为质数。于是算法的过程就很简单了，我们从2开始，对于每个未被标记的数字，将其看为质数，同时将其的倍数全部标false，直到根号n。然后，只需要接着遍历从根号n开始到n的这个距离中对应bool数组的取值，其中所有为true的都是质数

## 3的幂
本题也有多种方法  
1. 递归/循环，考虑到3的幂除以3之后要么为1，要么还是3的幂，可以借助这一性质设计递归函数
2. 由于3的幂可以表示为3^x，因此log_3(3^x)=x是个整数。因此可以考虑通过取其关于3的对数，看是否为整数来进行判断。在C++中实现时，有许多需要注意的地方  
	* C++中只有log和log10，我们需要利用换底公式来计算其余底的对数。同时注意，此处必须使用log10，这是因为log以e为底，结果误差较大，一般需要较准确的结果时利用log10
	* 要判断一个浮点数是否为整数，可以将其强转为int，然后判断该int与原double是否相等

## map和set的初始化
map可以用map<char, int> m = {{'s', 1}, {'d', 3}}，set可以用set<int> s = {1, 2, 3}

## 两层for循环和三层for循环的优化
对于两层的for循环，在任何时刻，内层的for循环都可以转化为一个map，通过索引map来以空间换时间，也可以转化为双指针。对于三层的for循环。任何时候内层的两个for都可以转化为双指针，双指针一个指头部，一个指尾部。（注意，转成双指针的话需要原数组排序才能发挥用场）

## string中的substr
substr(pos, n)——从pos开始取n个char  
substr(pos)——从pos开始取到结尾

## string中的find
find(const string &s, int pos = 0)——查找子串

## 最长回文子串
1. 动态规划（注意一下遍历的顺序）
2. 从中间向两边生长
3. 高级算法（Manacher's algorithm）

## 相交链表
本题需要观察到非常关键的一点，也即对于两个相交的链表，其从相交节点开始以后的节点都是一样的，因此如果我们从尾部开始往头部遍历，那么其应该是在相交节点处分叉，各自再往前。因此，对于两个长度不一样的链表，如果能够先将长的跳过其长出来的一部分，再和短的一起往下走，一定会同时碰到相交节点

## C++中的sort
sort为不稳定排序，如果需要保证key相同的数在输出中仍然按照输入中的顺序进行排列，需要使用stable_sort
另外，自定义比较函数的形式为bool compare(const Type &A, const Type &B)，其表示A和B的大小关系，在A小于B时返回true

## 前k个高频元素
对于需要取前k个元素的题目，我们可以考虑使用桶排序，其思路也很简单，我们先统计每个元素出现的次数，然后创建一个长度为n的数组，其中n为原数组的个数，接下来，将出现次数为i的元素放在数组的第i-1个位置，输出时只需要取后面k个有元素的数组位置即可

## 寻找峰值
题目要求在logN时间内完成，因此需要考虑二分。由于两端的元素都为负无穷，因此在二分时，先看中间节点，如果满足直接返回，否则，如果左边的节点较大就搜左边，右边较大就搜右边，两边都大搜一边即可。这是因为由于两端的元素为负无穷，因此左边区域最后一定存在至少一个点，其下一个点比其值小，于是，第一个这样的点一定是峰值点

## 搜索问题
搜索问题可以抽象为：先查看某个点（顺序搜索中选第一个点，二分查找选中间位置，二维矩阵搜索时选择左下角元素），然后根据这个点的值确定下一步搜索范围（顺序搜索中即为如果当前点不满足则找剩下元素，二分查找则根据大小关系选左或者右，二维搜索时根据大小关系向上/下移动）

## 跳跃游戏
本题看起来是动态规划，但其实贪心便可解决，因为我们只需要知道能否到达最后一个元素。因此，我们只需要从第一个元素开始，维护目前最远能到达的位置，如果这个位置大于等于最后一个元素的下标，则代表可以到达，对于每一个可达的元素，都看从这一点最远能到哪里，如果更远则更新最远位置

## 递归转循环
对于某一问题，常常可以分析搜索的路径。有些问题可以抽象为树的结构，如果能够抽象出来那么便可以使用对应的DFS/BFS搜索来解决问题。同时，这样的抽象也可以帮助我们转递归为迭代

## 至少有K个重复字符的最长子串
使用递归的方法，可以考虑到，对于某个字符串，我们可以统计其中每个字符出现的次数，如果所有字符出现的次数都大于等于k，那么直接返回，否则的话，对于出现次数小于k的字符，其不可能被包含在结果中，于是，我们可以将其看作分隔符，然后递归的计算分割出的子串

## 二叉树中的最大路径和
本题使用递归的思路，假设递归函数返回值代表最后一步在这个节点的路径的最大值，于是对于每个非空的节点，都对其左右子树分别调用，接下来进入关键的地方，我们首先要根据当前的情况更新一个全局的max变量，此时需要看左右子树的返回值，如果左右都不为负，那么目前值最大的路径的情况就是从左到根再到右，如果其中一个为负，那么目前最大值应该就是从左（右）到根，如果都为负那么最大情况就是当前根节点。接下来计算到达根节点的路径的最大值，此时只能是从左（右）到根不能再到右（左），于是根据情况判断即可

## lower_bound和upper_bound的使用
在**排好序的数组中**直接lower_bound返回的是第一个大于等于目标值的元素，直接upper_bound返回的是第一个大于目标值的元素（关于其返回值，可以理解为搜寻了一个全为目标值的区间，因此lower_bound就是这个区间的最小的那一个，upper_bound为最大的那一个的再外面一个）。同时，这两个函数也可以被重载，如果调用方式为：lower_bound(begin, end, num, greater\<int\>)，那么返回值将是第一个小于等于目标值的元素的迭代器  

## Priority Queue的使用
定义方式为：priority_queue<int, vector<int>, greater<int>> pq，或者priority_queue<iny, vector<int>, less<int>> pq。其中greater表示元素按升序排列，而less表示按降序排列。即如果希望第一个元素为最小的，则应该使用greater，这个可以与前面联合记忆，即greater->小、less->大  
Tips：在VSCODE中，要使用greater和less需要加入头文件xfunctional，但是在提交时可以删去

## 注意情况有无遗漏
对于题目，如果我们利用了prev指针，遍历的逻辑为使用一个prev指针指向之前访问的某个位置，接下来，当我们再次遇到某个符合条件的位置时，就根据prev和当前位置来进行某种操作。如果是这种情况，需要注意可能存在的情况遗漏的情况，也即有可能因为遍历结束（例如遍历完了整个数组），而遗漏了最后一种情况，注意进行检查！！

## 小技巧
有时候我们需要遍历例如当前节点的上下左右节点，如果分别写的话同样的代码需要写4次，显然不够高效。为了解决这一问题，我们可以利用两个数组存储出来对应的偏移，例如对于上述情况，我们可以初始化数组x为[-1,1,0,0]，数组y为[0,0,-1,1]，然后通过遍历这个数组便可完成对上下左右分别的遍历了

## multimap的使用
multimap也在头文件map中，在multimap中需要使用insert进行插入，在查找时，可以使用upper_bound和lower_bound查找第一个大于/第一个大于等于，也可以使用find查找第一个出现的位置，或者使用equal_range函数，返回该键值对应的所有value的迭代器

## 迭代器的使用
容器名::iterator ite

## ungetc(char, FILE*)
这个函数可以把getchar读取出来的字符放回缓冲区中

## cin和getline
注意cin读取的规则是跳过空白符一直到第一个字符然后一直读取到出现空白符号，而getline则是从第一个字符直接开始一直读到换行符，因此对于输入为
	aaa
	a b c
的这种情况，需要先cin读取aaa，然后使用一个getline把换行符读取了，然后再getline读取a b c

## 使用scanf读取
使用scanf读取数据需要注意，scanf的返回值为1、0或EOF，分别对应成功读到、未成功、读到文件结束处

## 再做题目
#### Leetcode
最大数  
摆动排序  
寻找重复数  
计算右侧小于当前元素的个数  
Safecracker  
Prim Path（题目中给出的步骤是**每次一步**，一般都是利用DFS/BFS）
Eqs  
生日快乐（有时看似有无穷多种可能，无法遍历，此时注意题目中是否存在限制条件可以约束。当自己的解法错误之后，尝试暴力遍历的思路！）  
**Tangled in Cables（最小生成树！Prim和Kruskal、UnionFind）**  
Til the Cows Come Homw（在写Dijkstra时，由于每步都需要取出当前最小距离估计的点，需要注意的是，**我们不能确保从源点开始与所有点都是连通的**，因此有可能有一步取不出来最小的点，那么这时，尽管可能还没有遍历完所有的点，仍然需要直接退出循环、bellman-ford）
迷宫城堡（Tarjan——强连通分支）  
过山车（匈牙利算法）  
Divide Groups（二分图的判断，染色算法）
